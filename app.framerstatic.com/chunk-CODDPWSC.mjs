import{s as w}from"https://app.framerstatic.com/chunk-FFXG44IK.mjs";var m;(e=>e.log=w("\u{1F4A9} fallback-logger-please-reassign:services"))(m||={});(i=>{i._isTesting=!1;let e;async function s(d,a){if(!i._isTesting)throw new Error("ServiceManager.isTesting must be true to use testWithShared()");if(e)throw new Error("ServiceManager.testWithShared() may not be nested");try{return e=d,await a()}finally{e=void 0}}i._testWithShared=s;function o(){if(i._isTesting){if(e)return e;throw new Error("ServiceManager.shared() may not be used while testing. Use testWithShared() for explicitness.")}}i._sharedServiceManagerIfTesting=o})(m||={});function T(r,e){throw e||new Error("Unexpected object: "+r)}var u=class extends Error{constructor(){super(...arguments);this.name="ServiceError.UnknownError";this.code=0;this.status=0;this.skipSentry=!1}};(p=>{let r;(c=>(c[c.serviceNotFound=404]="serviceNotFound",c[c.serviceNotCompatible=426]="serviceNotCompatible",c[c.serviceGone=410]="serviceGone",c[c.implementation=500]="implementation",c[c.timedOut=504]="timedOut",c[c.badRequest=400]="badRequest",c[c.badResponse=422]="badResponse"))(r=p.Code||={});class e extends p{constructor(){super(...arguments);this.code=404;this.name="ServiceError.ServiceNotFound"}}p.ServiceNotFound=e;class s extends p{constructor(){super(...arguments);this.code=426;this.name="ServiceError.ServiceNotCompatible"}}p.ServiceNotCompatible=s;class o extends p{constructor(){super(...arguments);this.code=410;this.name="ServiceError.ServiceGone";this.skipSentry=!0}}p.ServiceGone=o;class i extends p{constructor(){super(...arguments);this.code=500;this.name="ServiceError.Implementation"}}p.Implementation=i;class d extends p{constructor(){super(...arguments);this.code=504;this.name="ServiceError.TimedOut"}}p.TimedOut=d;class a extends p{constructor(){super(...arguments);this.code=400;this.name="ServiceError.BadRequest"}}p.BadRequest=a;class f extends p{constructor(l,S){super(l);this.code=422;this.name="ServiceError.BadResponse";this.response=S}}p.BadResponse=f;function h(t){if(!t)return new f;let n;x(t)&&(n=t.message);let l=C(t.code,n);return R(t)&&(l.code=t.code),E(t)&&(l.stack=t.stack),k(t)&&(l.skipSentry=t.skipSentry),I(t)&&(l.status=t.status),l}p.reconstructErrorResponse=h;function C(t,n){try{let l=t;switch(l){case 404:return new e(n);case 426:return new s(n);case 410:return new o(n);case 500:return new i(n);case 504:return new d(n);case 400:return new a(n);case 422:return new f(n);default:T(l)}}catch{return new p(n)}}function P(t){if(t instanceof p)return{code:t.code,message:t.message,stack:t.stack,skipSentry:t.skipSentry};let n,l,S,g,b;return typeof t=="string"?n=t:x(t)&&(n=t.message),E(t)&&(l=t.stack),k(t)&&(S=t.skipSentry),R(t)&&(g=t.code),I(t)&&(b=t.status),{code:g,message:n,stack:l,skipSentry:S,status:b}}p.toMessageBody=P})(u||={});function x(r){return typeof r=="object"&&r&&"message"in r&&typeof r.message=="string"}function E(r){return typeof r=="object"&&r&&"stack"in r&&typeof r.stack=="string"}function k(r){return typeof r=="object"&&r&&"skipSentry"in r&&typeof r.skipSentry=="boolean"}function R(r){return typeof r=="object"&&r&&"code"in r&&typeof r.code=="number"}function I(r){return typeof r=="object"&&r&&"status"in r&&typeof r.status=="number"}function V(r){m.log.error(r)}var v;(o=>{let r=Math.random;function e(){return`${r()}`}o.generateUniqueId=e;function s(){let i,d,a=new Promise((f,h)=>{i=f,d=h});return a.resolve=i,a.reject=d,a}o.newResolvablePromise=s})(v||={});var N=class{constructor(){this.newStream=e=>{let s=v.generateUniqueId();return new y((o,i)=>{this.iterators.push({id:s,update:o,done:i});let d=this.onNewStream?.(e);if(e?.replay==="latest"){let a=d?.latest??this.latestValue;if(a)o(a);else throw new u.Implementation('ServiceEventEmitter needs a "latest" value, but nothing has been emitted or returned by the onNewStream callback')}else if(d)throw new u.Implementation(`ServiceEventEmitter received a "latest" value from the onNewStream callback for a stream that didn't need it`)},()=>{let o=this.iterators.findIndex(i=>i.id===s);if(o>=0)this.iterators.splice(o,1);else throw new u.BadRequest(`ServiceEventEmitter couldn't find cancelled iterator with id: ${s}`)})};this.iterators=[];this.emit=e=>{this.latestValue=e;for(let s of this.iterators)s.update(e)};this.latest=()=>this.latestValue;this.hasStreams=()=>this.iterators.length>0}},y=class{constructor(e,s){this.onIteratorEnd=s;this.log=m.log.extend("ServiceStreamIterator");this.hasAsyncIterator=!1;this.updatesBeforeAsyncIterator=[];this.doneResult={done:!0,value:void 0};this.promises=[];this.update=e=>{let{hasAsyncIterator:s,updatesBeforeAsyncIterator:o,promises:i,returnedNextPromise:d}=this;if(!s){if(!e||e instanceof u)throw new u.BadRequest("ServiceStream received return or throw before being read");o.push(e);return}let a=i[this.promises.length-1];if(e&&a===void 0){if(!d){this.log.warn("lastPromise and returnedNextPromise should never both be undefined");return}a=d}if(e===void 0)a?.resolve(this.doneResult),d?.resolve(this.doneResult);else if(e instanceof u)d?.reject(e);else{if(this.onUpdate?.(e).ignore)return;i.push(v.newResolvablePromise()),a?.resolve({done:!1,value:e})}};this.next=async()=>{let e=this.promises.shift();return this.returnedNextPromise=e,e||this.doneResult};this.return=async()=>(this.update(void 0),this.onIteratorEnd?.(),this.doneResult);this.throw=async e=>(this.update(e),this.onIteratorEnd?.(),this.doneResult);this.read=async e=>{let s=this[Symbol.asyncIterator](),o=await s.next();for(;!o.done;)e(o.value),o=await s.next()};this.cancel=async()=>{await this.return()};this.promises=[v.newResolvablePromise()],e(this.update,this.update)}[Symbol.asyncIterator](e){if(this.hasAsyncIterator)throw new Error("ServiceStreamIterator.asyncIterator() may only be called once");return this.onUpdate=e,this.hasAsyncIterator=!0,this.updatesBeforeAsyncIterator.forEach(this.update),this.updatesBeforeAsyncIterator=[],this}};export{m as a,T as b,u as c,V as d,v as e,N as f};
//# sourceMappingURL=https://app.framerstatic.com/chunk-CODDPWSC.mjs.map
