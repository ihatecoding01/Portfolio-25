import{a as p,b as P,c as n,e as f}from"https://app.framerstatic.com/chunk-CODDPWSC.mjs";var c;(s=>{s.onewayRequestId="oneway",s.onewayStreamResponseIdPrefix="#oneway:";let t;(d=>(d.Request="request",d.Response="response",d.Error="error"))(t=s.MessageType||={});function r(i){return typeof i!="object"?!1:i.type==="request"||i.type==="response"||i.type==="error"}s.isMessage=r})(c||={});var l=typeof window>"u"?void 0:window,w="data:origin-not-initialized",M=class{constructor(e,t){this.target=e;this.trustedOrigin=w;this.listeners=new Set;this.onMessageEvent=e=>{this.log.trace(e.data,e.origin);let t=!1;if(e.source!==this.target)if(this===y&&e.source===l&&e.data?.__sourceRepresentsParentFrame)t=!0;else return;if(!t&&e.origin!==this.trustedOrigin&&this.trustedOrigin!=="*")throw this.trustedOrigin?new Error(`PostMessageChannel received a message with origin ${e.origin}, expected ${this.trustedOrigin}`):new Error(`PostMessageChannel received a message with origin ${e.origin}, but has not been configured with initializeTrustedOrigin`);if(this.interceptor?.handleRawEvent(e))return;let r=e.data;if(c.isMessage(r))for(let s of this.listeners)s(r)};let r=M.targetRepresentingParentFrame;if(e===(l?l.parent:void 0)||e===r){if(!b||y!==void 0)throw new Error("PostMessageChannel.toParentFrame must be used instead of initializing with window.parent.");if(l)l.parent!==l?this.target=l.parent:(this.target=r,this.disabled=r.disabled);else{this.target={postMessage:(...s)=>{this.log.debug("postMessage to parent channel not running in a DOM environment: ",s)}};return}}t!==w&&this.initializeTrustedOrigin(t)}get log(){return p.log.extend("PostMessageChannel")}static get toParentFrame(){return b=!0,y=y??new M(M.targetRepresentingParentFrame,w),b=!1,y}initializeTrustedOrigin(e){if(this.trustedOrigin!==w&&!(this===y&&e===this.trustedOrigin))throw new Error("PostMessageChannel can only be initialized with a trusted origin once");if(e!=="*"){if(!e.includes("://"))throw new Error(`PostMessageChannel can only be initialized with a concrete origin (https://...); received ${e}`)}this.trustedOrigin=e}postMessage(e){this.log.trace("\u2197\uFE0E",e),this.target.postMessage(e,this.trustedOrigin)}postMessageRaw(e){this.target.postMessage(e,this.trustedOrigin)}addMessageListener(e){this.listeners.size===0&&l?.addEventListener("message",this.onMessageEvent,!1),this.listeners.add(e)}removeMessageListener(e){this.listeners.delete(e),this.listeners.size===0&&l?.removeEventListener("message",this.onMessageEvent,!1)}static interceptMessageEventsFromOpenerFrame(e){B.setInterceptor(e)}setInterceptor(e){this.interceptor&&this.removeMessageListener(this.interceptor.unusedMessageListenerOnlyForCounting),this.interceptor=e?{handleRawEvent:e,unusedMessageListenerOnlyForCounting:()=>{}}:void 0,this.interceptor&&this.addMessageListener(this.interceptor.unusedMessageListenerOnlyForCounting)}},S=M;S.targetRepresentingParentFrame=(()=>{let e="__targetRepresentingParentFrame",t=l?.[e]??l?.webkit?.messageHandlers?.[e];return{disabled:!t,postMessage:(...r)=>{if(l){if(!t)throw new Error(`Can't find window.parent or ${e} message handler`)}else throw new Error("PostMessageChannel requires a DOM environment");t.postMessage(...r)}}})();var b=!1,y,q=S.toParentFrame,B=l&&l.opener&&l!==l.opener&&l.parent===l?new S(l.opener,w):q;var I;(t=>{function a(r){if(!r)return!1;switch(r.replay){case"latest":case void 0:break;default:return!1}return!0}t.isServiceStreamOptions=a;class e{constructor(s,i,o){this.method=s;this.options=i;this.helper=o;this.cancelled=!1;this.oneway=i?.oneway??!1}[Symbol.asyncIterator](){if(this.oneway)throw new n.BadRequest("Cannot read a oneway stream through an AsyncIterator. Use read() with a void callback instead.");return this.iterator=this.newIterator(),this.iterator}async read(s){for(this.iterator=this.newIterator(),this.oneway&&(this.onewayCallback=i=>{if(!O(i))throw new n.BadResponse("StreamReader.onewayCallback received an invalid iterator result");if(i.done)return;if(s(i.value))throw new n.BadRequest("ServiceStream callbacks cannot be async if oneway = true.")});;){let i=await this.iterator.next();if(i.done)return;await s(i.value)}}async cancel(){this.cancelled=!0,await this.iterator?.return?.()}newIterator(){if(this.iterator)throw new n.BadRequest("ServiceStream instances can only be read once. If multiple AsyncIterators or read() calls are required, create a new stream for each by calling the associated service method. To broadcast events with an observer pattern, consider using a client-specific EventEmitter or similar.");let s=f.generateUniqueId(),i={done:!0,value:void 0},o=async h=>{if(!O(h))throw new n.BadResponse("StreamReader.next received an invalid iterator result for next()");return h},v=async()=>{try{let h=await this.helper({method:this.method,argument:this.options,stream:{id:s,method:"next"}},this.onewayCallback);return await o(h)}catch(h){throw this.cancelled=!0,h}},d=async()=>(this.cancelled||await new Promise((h,g)=>{this.resolveCancelPromise=h,this.rejectCancelPromise=g}),i);return{next:async()=>this.cancelled?i:Promise.race([v(),d()]),return:async()=>(this.cancelled=!0,this.resolveCancelPromise?.(),this.helper({method:this.method,stream:{id:s,method:"return"}}),i),throw:async h=>(this.cancelled=!0,this.rejectCancelPromise?.(h),this.helper({method:this.method,stream:{id:s,method:"return"}}),i)}}}t.StreamReader=e})(I||={});function O(a){return a?a.done===!0||a.done===!1&&a.value!==void 0:!1}var R=class{constructor(e){this.log=e;this.expectWithoutDiscovery=(e,t)=>this.addRouter(t).expectWithoutDiscovery(e);this.discover=async(e,t,r={})=>this.addRouter(t).discover(e,r);this.unregister=async e=>{let t=[];for(let r of this.routers)r.channel===e&&t.push(r);if(t.length>0)for(let r of t)await r.unregisterAllImplementations(),this.routers.delete(r),r.destroy();else for(let r of this.routers)await r.unregisterImplementation(e)};this.routers=new Set;this.addRouter=e=>{for(let r of this.routers)if(r.channel===e)return r;let t=new C(e,this.log);return this.routers.add(t),t};this.testable={onlyRouter:()=>{if(this.routers.size!==1)throw new Error(`onlyRouter called on a ServiceManager with ${this.routers.size} routers, expected 1`);return this.routers.values().next().value}}}register(e){function t(r){return"service"in r&&"implementation"in r&&r.service!==void 0&&r.implementation!==void 0}return t(e)?(this.addRouter(e.channel).registerImplementation(e.implementation,e.service),()=>void this.unregister(e.implementation)):(this.addRouter(e.channel),()=>void this.unregister(e.channel))}};(t=>{let a;function e(){return a=a??new t,p._sharedServiceManagerIfTesting()??a}t.shared=e})(R||={});var C=class{constructor(e,t){this.channel=e;this.customLogger=t;this.onMessage=e=>{try{e.type===c.MessageType.Request?e.id===c.onewayRequestId?this.onOnewayRequest(e):this.onRequest(e):e.type===c.MessageType.Response?e.method===m.method?this.onDiscoveryResponse(e):this.onResponse(e):e.type===c.MessageType.Error?this.onErrorResponse(e):P(e.type,new Error(`Unknown message: ${JSON.stringify(e)}`))}catch(t){this.log.reportError(t,{message:e})}};this.waitingDiscoveryMap={};this.reflectDiscoveredServices=()=>{let e=this.latestDiscoveryInfo?Object.keys(this.latestDiscoveryInfo.services):[],t;this.channel.disabled&&(e=Object.keys(this.waitingDiscoveryMap),t=new n.ServiceNotFound);for(let r of e){let s=this.waitingDiscoveryMap[r];s&&(this.waitingDiscoveryMap[r]=[],s.forEach(i=>t?i.reject(t):i.resolve()))}};this.onDiscoveryResponse=e=>{if(m.isValidInfo(e.body))this.latestDiscoveryInfo=e.body,this.reflectDiscoveredServices(),this.log.trace("\u2198\uFE0F Discovered services",e.body);else throw new n.BadResponse("Invalid discovery response",e);e.id!==m.broadcastMessageId&&this.onResponse(e)};this.broadcastDiscoveryInfo=e=>{let t={};for(let[s,i]of Object.entries(this.implementedServices)){let o=i.service;t[s]={fingerprint:o.fingerprint}}let r={services:t};try{this.channel.postMessage({type:c.MessageType.Response,id:e||m.broadcastMessageId,serviceId:m.serviceId,method:m.method,body:r})}catch{}};this.onewayPromise=Promise.resolve(void 0);this.expectWithoutDiscovery=e=>(this.log.trace("\u260E\uFE0F expectWithoutDiscovery",e.id),e.newOutgoingWrapper(async(t,r)=>t.oneway?(this.postOnewayRequest(e.id,t),this.onewayPromise):(await this.waitForDiscoveryInfo(1e3),this.throwErrorIfBadService(e),this.postRequest(e.id,t,void 0,r))));this.discover=async(e,{timeout:t=3e4}={})=>{this.log.trace("\u260E\uFE0F discover",e.id);let r=[this.waitForDiscoveredService(e,t)];return t!==1/0&&r.push(E(t).then(()=>{throw this.latestDiscoveryInfo?new n.ServiceNotFound(e.id):new n.TimedOut(e.id)})),await Promise.race(r),this.throwErrorIfBadService(e),this.expectWithoutDiscovery(e)};this.throwErrorIfBadService=e=>{let t=this.latestDiscoveryInfo,r=t&&t?t.services[e.id]:void 0;if(!r)throw this.log.warn("\u260E\uFE0F Couldn't find service",e.id,t),new n.ServiceNotFound(e.id);if(r.fingerprint!==e.fingerprint)throw this.log.warn("\u260E\uFE0F Couldn't find service with required version fingerprint. Make sure both endpoints are using the same version of the Services package.",t),new n.ServiceNotCompatible(e.id)};this.postOnewayRequest=(e,t)=>{this.channel.postMessage({type:c.MessageType.Request,id:c.onewayRequestId,serviceId:e,method:t.method,body:t.argument})};this.postRequest=(e,t,r,s)=>{if(this.log.trace("\u2197\uFE0F",e,t),!!(this.channel.disabled??!1))return Promise.reject(new n.ServiceNotFound(e));let o={type:c.MessageType.Request,id:f.generateUniqueId(),serviceId:e,method:t.method,stream:T.toMessage(t.stream),body:t.argument},v=f.newResolvablePromise();this.waitingRequestsMap[o.id]={result:v,onStreamValue:s},this.channel.postMessage(o);let d=[v];return typeof r=="number"&&d.push(E(r).then(()=>{throw new n.TimedOut})),Promise.race(d).then(h=>h?.body).catch(h=>{throw delete this.waitingRequestsMap[o.id],h})};this.waitingRequestsMap={};this.onResponse=e=>{let t=e.id,r=t.startsWith(c.onewayStreamResponseIdPrefix);r&&(t=t.substr(c.onewayStreamResponseIdPrefix.length));let s=this.waitingRequestsMap[t];if(r)s&&e.body&&s.onStreamValue?.(e.body);else{if(!s)return this.log.warn("\u260E\uFE0F onResponse: couldn't find request",e);delete this.waitingRequestsMap[t],s.result.resolve(e)}};this.onErrorResponse=(e,t)=>{let r=this.waitingRequestsMap[e.id];if(!r)return this.log.warn("\u260E\uFE0F onErrorResponse: couldn't find request",e);delete this.waitingRequestsMap[e.id];let s=t||n.reconstructErrorResponse(e.body);r.result.reject(s)};this.implementedServices={};this.unregisteredServices=new Set;this.registerImplementation=(e,t)=>{this.log.trace("\u260E\uFE0F registerImplementation",t.id,e);let r={};for(let s in t.methods){let i=s,o=e[i];if(typeof o!="function")throw new n.Implementation(`Implementation for ${t.id} doesn't correctly implement ${i}()`);r[i]=o.bind(e)}this.unregisteredServices.delete(t.id),this.implementedServices[t.id]={service:t,rawImplementation:e,implementation:Object.freeze(r)},this.broadcastDiscoveryInfo()};this.unregisterImplementation=async e=>{let t=e===this.unregisterAllToken;t||this.log.trace("\u260E\uFE0F unregisterImplementation",e);let r=!1,s=[];for(let[i,o]of Object.entries(this.implementedServices))if(!(!t&&o.rawImplementation!==e)){this.unregisteredServices.add(i),delete this.implementedServices[i],r=!0;for(let[v,d]of Object.entries(this.requestedStreamsMap))d?.serviceId===i&&s.push({id:v,error:new n.ServiceGone(i)})}await this.cancelStreams(s),r&&this.broadcastDiscoveryInfo()};this.unregisterAllToken={};this.unregisterAllImplementations=async()=>{this.log.debug("\u260E\uFE0F unregisterAllImplementations"),await this.unregisterImplementation(this.unregisterAllToken)};this.requestedStreamsMap={};this.cancelStreams=async e=>{let t=[];for(let{id:r,error:s}of e){let i=this.requestedStreamsMap[r];delete this.requestedStreamsMap[r],i?.iterator.throw&&t.push(i.iterator.throw(s))}await Promise.all(t)};this.onRequest=async e=>{if(e.method===m.method){this.broadcastDiscoveryInfo(e.id);return}let t=c.MessageType.Response,r,s=!1;try{let i=this.implementedServices[e.serviceId],o=i?.implementation;if(!o)throw this.unregisteredServices.has(e.serviceId)?new n.ServiceGone(e.serviceId):new n.BadRequest;this.log.trace("\u2198\uFE0F",e.serviceId,e);let v=o[e.method];if(!e.stream)r=await v(e.body);else{let{id:d,method:h}=T.fromMessage(e.stream),g=this.requestedStreamsMap[d];if(h==="next"){if(!g){let u=I.isServiceStreamOptions(e.body)?e.body:void 0;g={iterator:(await v(u))[Symbol.asyncIterator](u?.oneway?F=>(this.channel.postMessage({type:c.MessageType.Response,id:c.onewayStreamResponseIdPrefix+e.id,serviceId:e.serviceId,method:e.method,body:{done:!1,value:F}}),{ignore:!0}):void 0),serviceId:i.service.id},this.requestedStreamsMap[d]=g}try{let u=await g.iterator.next();r={done:u.done,value:u.value}}catch(u){throw s=u instanceof n.ServiceGone,u}}else if(h==="return"){delete this.requestedStreamsMap[d];let u=g?.iterator.return;u&&await u(),r={done:!0,value:void 0}}else throw new n.BadRequest("Stream operations other than next() and return() are not yet supported")}}catch(i){t=c.MessageType.Error,r=n.toMessageBody(i),s||this.log.warn("\u260E\uFE0F onRequest: error",e,i)}finally{this.channel.postMessage({type:t,id:e.id,serviceId:e.serviceId,method:e.method,body:r})}};this.onOnewayRequest=e=>{try{let r=this.implementedServices[e.serviceId]?.implementation;if(!r)throw this.unregisteredServices.has(e.serviceId)?new n.ServiceGone(e.serviceId):new n.BadRequest;this.log.trace("\u2198\uFE0F",e.serviceId,e);let s=r[e.method];s(e.body)}catch(t){this.log.warn("\u260E\uFE0F onOnewayRequest: error",e,t)}};this.testable={waitingRequestsMap:()=>this.waitingRequestsMap};e.addMessageListener(this.onMessage)}get log(){return this.customLogger??p.log}destroy(){this.channel.removeMessageListener(this.onMessage)}async waitForDiscoveryInfo(e,t=0){if(this.latestDiscoveryInfo)return this.latestDiscoveryInfo;let r=e/(t+1),s=0;for(;s<=t;)try{await this.postRequest(m.serviceId,{method:m.method},r);break}catch(i){if(!(i instanceof n.TimedOut))throw i;if(!this.isWaitingForDiscovery())break;s++}if(!this.latestDiscoveryInfo)throw new n.ServiceNotFound;return this.latestDiscoveryInfo}isWaitingForDiscovery(){return Object.values(this.waitingDiscoveryMap).some(e=>e&&e.length>0)}async waitForDiscoveredService(e,t){let r=f.newResolvablePromise(),s=this.waitingDiscoveryMap[e.id]||[],i=this.isWaitingForDiscovery();return this.waitingDiscoveryMap[e.id]=s,s.push(r),i||this.waitForDiscoveryInfo(t,2).catch(()=>{}),this.reflectDiscoveredServices(),r}},m;(s=>{s.serviceId="",s.method="#discover",s.broadcastMessageId="";function r(i){return!!(i&&typeof i=="object"&&"services"in i&&typeof i.services=="object")}s.isValidInfo=r})(m||={});var T;(s=>{let a="#return:",e="#throw:";function t(i){return i.startsWith(a)?{id:i.substr(a.length),method:"return"}:i.startsWith(e)?{id:i.substr(e.length),method:"throw"}:{id:i,method:"next"}}s.fromMessage=t;function r(i){if(i)switch(i.method){case"next":return i.id;case"return":return a+i.id;case"throw":return e+i.id;default:return}}s.toMessage=r})(T||={});function E(a){return new Promise(e=>{setTimeout(e,a)})}var x=class{constructor(){this.listeners=new Set}get log(){return p.log.extend("LocalChannel")}postMessage(e){this.log.trace("\u2197\uFE0E",e),this.listeners.forEach(t=>t(e))}addMessageListener(e){this.listeners.add(e)}removeMessageListener(e){this.listeners.delete(e)}},Z=new x;var D=class{constructor(e){this.port=e;this.listeners=new Set;this.onMessageEvent=e=>{this.log.trace(e);let t=e.data;if(c.isMessage(t))for(let r of this.listeners)r(t)}}get log(){return p.log.extend("MessagePortChannel")}postMessage(e){this.log.trace("\u2197\uFE0E",e),this.port.postMessage(e)}addMessageListener(e){this.listeners.size===0&&(this.port.start(),this.port.addEventListener("message",this.onMessageEvent,!1)),this.listeners.add(e)}removeMessageListener(e){this.listeners.delete(e),this.listeners.size===0&&this.port.removeEventListener("message",this.onMessageEvent,!1)}};var k;(s=>{function a(i,o,v,d){v({method:i,argument:o?d:void 0,oneway:!0})}s.onewayMethodTemplate=a;async function e(i,o,v,d){await v({method:i,argument:o?d:void 0})}s.voidMethodTemplate=e;async function t(i,o,v,d){return await v({method:i,argument:o?d:void 0})}s.valueMethodTemplate=t;function r(i,o,v){return new I.StreamReader(i,v,o)}s.streamMethodTemplate=r})(k||={});export{R as a,Z as b,D as c,S as d,q as e,B as f,k as g};
//# sourceMappingURL=https://app.framerstatic.com/chunk-OAFMPNTH.mjs.map
